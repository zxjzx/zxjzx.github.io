(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{260:function(n,t,r){"use strict";r.r(t);var e={name:"javascript",created:function(){}},o=r(29),s=Object(o.a)(e,(function(){var n=this.$createElement;this._self._c;return this._m(0)}),[function(){var n=this.$createElement,t=this._self._c||n;return t("div",[t("script",[this._v("\n        //arguments\n        function _new() {\n            console.log(arguments);\n            console.log(arguments.callee===_new); //让匿名函数指向本身\n            let iterator = arguments[Symbol.iterator]();\n            console.log(iterator); // 迭代函数生成的迭代器\n            console.log(iterator.next());//迭代器枚举的值\n\n            let args = Array.prototype.slice.call(arguments); //将传入的参数转换为数组\n            console.log(args)\n        }\n        _new([1],2,3);\n    ")]),this._v(" "),t("script",[this._v("\n        //new 实现原理\n        function _new() {\n            let target = {};\n            // console.log(arguments)\n            let [constructor,...args] = [...arguments];\n            // console.log(constructor.prototype);\n            target.__proto__ = constructor.prototype;\n            let result = constructor.apply(target,args);\n            // console.log(args);\n            return target;\n\n        }\n        let obj = _new();\n    ")]),this._v(" "),t("script",[this._v("\n\n        //\n        function add(a) {\n            return function (b) {\n                return a+b\n            }\n        }\n        add(3)(4);\n\n\n        //柯里化函数的实现\n        // 是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回一个新的函数的技术，新函数接受余下参数并返回运算结果\n        function sumFun(a,b,c) {\n            return a+b+c;\n        }\n        const curry = (fn,...args)=>args.length<fn.length?(...arguments)=>curry(fn,...args,...arguments):fn(...args);\n        let sum = curry(sumFun);\n\n        console.log(sum(2)(3)(4)); //9\n\n        // 作用：参数复用，提前返回，返回接受余下的参数且返回结果的新函数\n        // 延迟执行-返回新函数，等待执行\n\n    ")])])}],!1,null,"3e8a3515",null);t.default=s.exports}}]);